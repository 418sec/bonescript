// Copyright (C) 2011 - Texas Instruments, Jason Kridner
//
//
var fs = require('fs');
var child_process = require('child_process');
var winston = require('winston');
var eeprom = require('./eeprom');
var parse = require('./parse');
var bone = require('./bone');
var functions = require('./functions');
var serial = require('./serial');
var iic = require('./iic');
var my = require('./my');
var package_json = require('./package.json');
var g = require('./constants');
var epoll = my.require('epoll');

var debug = true;

// Detect if we are on a Beagle
var simulator = true;
try {
    var cpuinfo = fs.readFileSync('/proc/cpuinfo', 'utf-8');
    if(debug) winston.debug('cpuinfo = ' + cpuinfo);
    // Need to add a test here that is valid on BeagleBone
} catch(ex) {
}

winston.setLevels(winston.config.syslog.levels);
if(debug) {
    winston.add(winston.transports.File, {
        filename: '/var/lib/cloud9/bonescript.log',
        level: 'warn'
    });
}

winston.debug('index.js loaded');

var f = {};

// Keep track of allocated resources
var gpio = [];
var pwm = {};

// returned object has:
//  mux: index of mux mode
//  options: array of mode names
//  slew: 'fast' or 'slow'
//  rx: 'enabled' or 'disabled'
//  pullup: 'diabled', 'pullup' or 'pulldown'
//  pin: key string for pin
//  name: pin name
//  pwm: object if pwm enabled, undefind otherwise
//    freq: frequency of PWM
//    value: duty cycle of PWM as number between 0 and 1
//  gpio: object if GPIO enabled, undefined otherwise
//    active: GPIO is enabled by the kernel
//    allocated: boolean for if it is allocated by this application
//    direction: 'in' or 'out' (allocated might be false)
f.getPinMode = function(pin, callback) {
    if(debug) winston.debug('getPinMode(' + pin + ');');
    pin = my.getpin(pin);
    var mode = {'pin': pin.key, 'name': pin.name};
    if(pin.options) mode.options = pin.options;

    // Get PWM settings if applicable
    if((typeof pin.pwm != 'undefined')
        && (typeof pwm[pin.pwm.name] != 'undefined')
        && (pin.key == pwm[pin.pwm.name].key)) {
        mode.pwm = {};
        try {
            if(typeof pwm[pin.pwm.name].pwm_test_path === 'string') {
                var period = fs.readFileSync(pwm[pin.pwm.name].pwm_test_path+'/period');
                var duty = fs.readFileSync(pwm[pin.pwm.name].pwm_test_path+'/duty');
                mode.pwm.freq = 1.0e9 / period;
                mode.pwm.value = duty / period;
            } else {
                var duty_percent = fs.readFileSync(pwm[pin.pwm.name].old_pwm_path+'/duty_percent');
                mode.pwm.freq = fs.readFileSync(pwm[pin.pwm.name].old_pwm_path+'/period_freq');
                mode.pwm.value = duty_percent / 100.0;
            }
        } catch(ex) {
            mode.pwm.freq = undefined;
            mode.pwm.value = undefined;
        }
    }

    // Get GPIO settings if applicable
    if((typeof pin.gpio != 'undefined')) {
        var n = pin.gpio;
        var directionFile = "/sys/class/gpio/gpio" + n + "/direction";
        if(my.file_existsSync(directionFile)) {
            mode.gpio = {};
            mode.gpio.active = true;
            var direction = fs.readFileSync(directionFile, 'utf-8');
            direction = direction.replace(/^\s+|\s+$/g, '');
            mode.gpio.direction = direction;
            if(gpio[n] && gpio[n].path) {
                mode.gpio.allocated = true;
            } else {
                mode.gpio.allocated = false;
            }
        }
    }

    // Get pinmux settings
    var muxFile = '/sys/kernel/debug/omap_mux/' + pin.mux;
    var pinctrlFile = '/sys/kernel/debug/pinctrl/44e10800.pinmux/pins';
    var muxRegOffset = parseInt(pin.muxRegOffset, 16);
    var readOmapMux = function(err, data) {
        if(err) { 
            mode.err = 'readOmapMux error: ' + err;
            if(debug) winston.debug(mode.err);
            callback(mode);
        }
        mode = parse.modeFromOmapMux(data, mode);
        callback(mode);
    };
    var readPinctrl = function(err, data) {
        if(err) {
            mode.err = 'readPinctrl error: ' + err;
            if(debug) winston.debug(mode.err);
            callback(mode);
        }
        mode = parse.modeFromPinctrl(data, muxRegOffset, 0x44e10800, mode);
        callback(mode);
    };
    var tryPinctrl = function(exists) {
        if(exists) {
            fs.readFile(pinctrlFile, 'utf8', readPinctrl);
        } else {
            if(debug) winston.debug('getPinMode(' + pin.key + '): no valid mux data');
            callback(mode);
        }
    };
    var tryOmapMux = function(exists) {
        if(exists) {
            fs.readFile(muxFile, 'utf8', readOmapMux);
        } else {
            my.file_exists(pinctrlFile, tryPinctrl);
        }
    };
    if(callback) {
        my.file_exists(muxFile, tryOmapMux);
    } else {
        try {
            var data = fs.readFileSync(muxFile, 'utf8');
            mode = parse.modeFromOmapMux(data, mode);
        } catch(ex) {
            try {
                var data2 = fs.readFileSync(pinctrlFile, 'utf8');
                mode = parse.modeFromPinctrl(data2, muxRegOffset, 0x44e10800, mode);
            } catch(ex2) {
                if(debug) winston.debug('getPinMode(' + pin.key + '): ' + ex2);
            }
        }
        return(mode);
    }
};
f.getPinMode.args = ['pin', 'callback'];

f.pinMode = function(pin, direction, mux, pullup, slew, callback) {
    if(debug) winston.debug('pinMode(' + [pin, direction, mux, pullup, slew] + ');');
    pin = my.getpin(pin);
    if(direction == g.INPUT_PULLUP) pullup = 'pullup';
    pullup = pullup || ((direction == g.INPUT) ? 'pulldown' : 'disabled');
    slew = slew || 'fast';
    mux = mux || 7; // default to GPIO mode
    var resp = {value: true};
    var template = 'bspm';
    
    if(direction == g.ANALOG_OUTPUT || mux == g.ANALOG_OUTPUT) {
        if((typeof pin.pwm == 'undefined') || 
                (typeof pin.pwm.muxmode == 'undefined')) {
            var err = 'pinMode only supports ANALOG_OUTPUT for PWM pins: ' + pin.key;
            winston.info(err);
            if(callback) callback({value:false, err:err});
            return(false);
        }
        direction = g.OUTPUT;
        mux = pin.pwm.muxmode;
        template = 'bspwm';
    }
    
    if(!pin.mux) {
        if(debug) winston.debug('Invalid pin object for pinMode: ' + pin);
        throw('Invalid pin object for pinMode: ' + pin);
    }

    var muxFile = '/sys/kernel/debug/omap_mux/' + pin.mux;
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    var n = pin.gpio;
    
    // Handle case where pin is allocated as a gpio-led
    if(pin.led) {
        if((direction != g.OUTPUT) || (mux != 7)) {
            resp.err = 'pinMode only supports GPIO output for LEDs: ' + pin.key;
            winston.info(resp.err);
            resp.value = false;
            if(callback) callback(resp);
            return(false);
        }
        gpioFile = '/sys/class/leds/beaglebone::' + pin.led + '/brightness';
        var pathA = "/sys/class/leds/beaglebone:";
        var pathB = pathA;
        pathA += ":" + pin.led + "/trigger";
        pathB += "green:" + pin.led + "/trigger";
        if(my.file_existsSync(pathA)) {
            fs.writeFileSync(pathA, "gpio");
        } else {
            if(my.file_existsSync(pathB)) {
                fs.writeFileSync(pathB, "gpio");
            } else {
                resp.err = "Unable to find LED: " + pin.led;
                winston.error(resp.err);
                resp.value = false;
            }
        }
        gpio[n] = {'path': gpioFile};
        if(callback) callback(resp);
        return(resp.value);
    }

    // Figure out the desired value
    var pinData = my.pin_data(slew, direction, pullup, mux);
   
    if(my.is_capemgr()) {
        my.create_dt(pin, pinData, template);
    } else {
        try {
            var fd = fs.openSync(muxFile, 'w');
            fs.writeSync(fd, pinData.toString(16), null);
        } catch(ex) {
            if(debug) winston.debug('Unable to configure mux for pin ' + pin + ': ' + ex);
            // Don't exit yet --- need to try using pinmux-helper with devicetree
            // ... and it might work if the pin is already muxed to 7
            if(debug) winston.debug('mode = ' + JSON.stringify(f.getPinMode(pin)));
            var currentMode = f.getPinMode(pin);
            if(currentMode.mux != mux) {
                resp.value = false;
                resp.err = 'Unable to configure mux for pin ' + pin.key + ': ' + ex;
                winston.info(resp.err);
                gpio[n] = {};
                if(callback) callback(resp);
                return(resp.value);
            }
        }
    }
    
    // Enable GPIO, if not already done
    if(mux == 7) {
        if(!gpio[n] || !gpio[n].path) {
            gpio[n] = {'path': gpioFile};
    
            // Export the GPIO controls
            var exists = my.file_existsSync(gpioFile);
            if(exists) {
                if(debug) winston.debug("gpio: " + n + " already exported.");
                fs.writeFileSync("/sys/class/gpio/gpio" + n + "/direction",
                    direction, null);
            } else {
                try {
                    if(debug) winston.debug("exporting gpio: " + n);
                    fs.writeFileSync("/sys/class/gpio/export", "" + n, null);
                    if(debug) winston.debug("setting gpio " + n +
                        " direction to " + direction);
                    fs.writeFileSync("/sys/class/gpio/gpio" + n + "/direction",
                        direction, null);
                } catch(ex2) {
                    resp.value = false;
                    resp.err = 'Unable to export gpio-' + n + ': ' + ex2;
                    if(debug) winston.debug(resp.err);
                    var gpioUsers =
                        fs.readFileSync('/sys/kernel/debug/gpio', 'utf-8');
                    gpioUsers = gpioUsers.split('\n');
                    for(var x in gpioUsers) {
                        var y = gpioUsers[x].match(/gpio-(\d+)\s+\((\S+)\s*\)/);
                        if(y && y[1] == n) {
                            resp.err += '\nconsumed by ' + y[2];
                            if(debug) winston.debug(resp.err);
                        }
                    }
                    gpio[n] = {};
                    if(callback) callback(resp);
                    return(resp.value);
                }
            }
        }
    } else {
        gpio[n] = {};
    }
    
    if(callback) callback(resp);
    return(resp.value);
};
f.pinMode.args = ['pin', 'direction', 'mux', 'pullup', 'slew', 'callback'];

f.digitalWrite = function(pin, value, callback) {
    var myCallback = function() {};
    if(callback) myCallback = function(resp) {
        if(!resp || (typeof resp != 'object')) resp = {'data': resp};
        callback(resp);
    };
    if(debug) winston.debug('digitalWrite(' + [pin, value] + ');');
    pin = my.getpin(pin);
    value = parseInt(Number(value), 2) ? 1 : 0;
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    if(pin.led) {
        var pathA = "/sys/class/leds/beaglebone:";
        var pathB = pathA;
        pathA += ":" + pin.led + "/brightness";
        pathB += "green:" + pin.led + "/brightness";
        if(my.file_existsSync(pathA)) {
            gpioFile = pathA;
        } else {
            if(my.file_existsSync(pathB)) {
                gpioFile = pathB;
            } else {
                winston.error("Unable to find LED: " + pin.led);
            }
        }
    }
    if(debug) winston.debug("gpioFile = " + gpioFile);
    if(callback) {
        fs.writeFile(gpioFile, '' + value, null, myCallback);
    } else {
        try {
            fs.writeFileSync(gpioFile, '' + value, null);
        } catch(ex) {
            winston.error("Unable to write to " + gpioFile);
        }
    }
    return(true);
};
f.digitalWrite.args = ['pin', 'value', 'callback'];

f.digitalRead = function(pin, callback) {
    if(debug) winston.debug('digitalRead(' + [pin] + ');');
    var resp = {};
    pin = my.getpin(pin);
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    if(callback) {
        var readFile = function(err, data) {
            if(err) {
                resp.err = 'digitalRead error: ' + err;
                winston.error(resp.err);
            }
            resp.value = parseInt(data, 2);
            callback(resp);
        };
        fs.readFile(gpioFile, readFile);
        return(true);
    }
    resp.value = parseInt(fs.readFileSync(gpioFile), 2);
    return(resp.value);
};
f.digitalRead.args = ['pin', 'callback'];

f.analogRead = function(pin, callback) {
    if(debug) winston.debug('analogRead(' + [pin] + ');');
    pin = my.getpin(pin);
    if(typeof this.ainPrefix == 'undefined') {
        if(my.load_dt('cape-bone-iio')) {
            var ocp = my.file_find('/sys/devices', 'ocp.', 1000);
            var helper = my.file_find(ocp, 'helper.', 10000);
            this.ainPrefix = helper + '/AIN';
            this.indexOffset = 0;
            this.scale = 1800;
        } else {
            this.ainPrefix = '/sys/bus/platform/devices/tsc/ain';
            this.indexOffset = 1;
            this.scale = 4096;
        }
    }
    var ainPrefix = this.ainPrefix;
    var indexOffset = this.indexOffset;
    var scale = this.scale;
    var ainFile = ainPrefix + (pin.ain + indexOffset).toString();
    if(callback) {
        var readFile = function(err, data) {
            if(err) {
                delete this.ainPrefix;
                winston.error('analogRead error: ' + err);
            }
            var value = parseInt(data, 10) / scale;
            callback({'value': value});
        };
        fs.readFile(ainFile, readFile);
        return(true);
    }
    var data = parseInt(fs.readFileSync(ainFile), 10);
    if(isNaN(data)) {
        delete this.ainPrefix;
        throw('analogRead(' + pin.key + ') returned ' + data);
    }
    data = data / scale;
    if(isNaN(data)) {
        delete this.ainPrefix;
        throw('analogRead(' + pin.key + ') scaled to ' + data);
    }
    return(data);
}; 
f.analogRead.args = ['pin', 'callback'];

f.shiftOut = function(dataPin, clockPin, bitOrder, val, callback) {
    if(debug) winston.debug('shiftOut(' + [dataPin, clockPin, bitOrder, val] + ');');
    dataPin = my.getpin(dataPin);
    clockPin = my.getpin(clockPin);
    var i = 0;
    var bit;
    var clock = 0;

    function next() {
        if(debug) winston.debug('i = ' + i);
        if(debug) winston.debug('clock = ' + clock);
        if(i == 8) return(callback());
        if(bitOrder == g.LSBFIRST) {
            bit = val & (1 << i);
        } else {
            bit = val & (1 << (7 - i));
        }
        if(clock === 0) {
            clock = 1;
            if(bit) {
                f.digitalWrite(dataPin, g.HIGH, next);
            } else {
                f.digitalWrite(dataPin, g.LOW, next);
            }
        } else if(clock == 1) {
            clock = 2;
            f.digitalWrite(clockPin, g.HIGH, next);
        } else if(clock == 2) {
            i++;
            clock = 0;
            f.digitalWrite(clockPin, g.LOW, next);
        }
    }

    if(callback) {
        next();
    } else {
        for(i = 0; i < 8; i++) {
            if(bitOrder == g.LSBFIRST) {
                bit = val & (1 << i);
            } else {
                bit = val & (1 << (7 - i));
            }

            if(bit) {
                f.digitalWrite(dataPin, g.HIGH);
            } else {
                f.digitalWrite(dataPin, g.LOW);
            }
            f.digitalWrite(clockPin, g.HIGH);
            f.digitalWrite(clockPin, g.LOW);
        }
    }
};
f.shiftOut.args = ['dataPin', 'clockPin', 'bitOrder', 'val', 'callback'];

f.attachInterrupt = function(pin, handler, mode, callback) {
    if(debug) winston.debug('attachInterrupt(' + [pin, handler, mode] + ');');
    pin = my.getpin(pin);
    var resp = {'pin':pin, 'attached': false};
    if(!epoll.exists) {
        resp.err = 'attachInterrupt: requires Epoll module';
        if(debug) winston.debug(resp.err);
        if(callback) callback(resp);
        return(resp.attached);
    }
    if(!gpio[pin.gpio]) {
        resp.attached = false;
        resp.configured = false;
        if(callback) callback(resp);
        return(resp.attached);
    }
    if(gpio[pin.gpio].intProc) {
        resp.attached = false;
        resp.configured = true;
        if(callback) callback(resp);
        return(resp.attached);
    }
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    var valuefd = fs.openSync(gpioFile, 'r');
    var value = new Buffer(1);
    fs.writeFileSync('/sys/class/gpio/gpio' + pin.gpio + '/edge', mode);
    handler = (typeof handler === "string") ? my.myeval('(' + handler + ')') : handler;
    var intHandler = function(err, fd, events) {
        if(err) {
            m.err = err;
        }
        fs.readSync(valuefd, value, 0, 1, 0);
        var m = {};
        m.pin = pin;
        m.value = parseInt(Number(value), 2);
        if(typeof handler =='function') m.output = handler(m);
        else m.output = {handler:handler};
        if(m.output && (typeof callback == 'function')) callback(m);
    };
    gpio[pin.gpio].intProc = new epoll.Epoll(intHandler);
    fs.readSync(valuefd, value, 0, 1, 0);
    gpio[pin.gpio].intProc.add(valuefd, epoll.Epoll.EPOLLPRI);
    gpio[pin.gpio].intProc.valuefd = valuefd;
    resp.attached = true;
    if(callback) callback(resp);
    return(resp.attached);
};
f.attachInterrupt.args = ['pin', 'handler', 'mode', 'callback'];

f.detachInterrupt = function(pin, callback) {
    if(debug) winston.debug('detachInterrupt(' + [pin] + ');');
    pin = my.getpin(pin);
    if(!gpio[pin.gpio] || !gpio[pin.gpio].intProc) {
        if(callback) callback({'pin':pin, 'detached':false});
        return(false);
    }
    gpio[pin.gpio].intProc.remove(gpio[pin.gpio].intProc.valuefd);
    delete gpio[pin.gpio].intProc;
    if(callback) callback({'pin':pin, 'detached':true});
    return(true);
};
f.detachInterrupt.args = ['pin', 'callback'];

// See http://processors.wiki.ti.com/index.php/AM335x_PWM_Driver's_Guide
// That guide isn't useful for the new pwm_test interface
f.analogWrite = function(pin, value, freq, callback) {
    if(debug) winston.debug('analogWrite(' + [pin,value,freq] + ');');
    pin = my.getpin(pin);
    freq = freq || 2000.0;
    var path = '';

    // Make sure the pin has a pwm associated
    if(typeof pin.pwm == 'undefined') {
        throw(pin.key + ' does not support analogWrite()');
    }

    // Make sure it no one else who has the pwm
    if((typeof pwm[pin.pwm.name] != 'undefined') && (pin.key != pwm[pin.pwm.name].key)) {
        throw(pin.key + ' requires pwm ' + pin.pwm.name +
            ' but it is already in use by ' +
            pwm[pin.pwm].key
        );
    }

    // Make sure pwm[].key and pwm[].(pwm_test_path|old_pwm_path) are valid
    if(typeof pwm[pin.pwm.name] == 'undefined') {
        pwm[pin.pwm.name] = {};
        pwm[pin.pwm.name].key = pin.key;
        var pinMode = f.getPinMode(pin.key);
        var slew = pinMode.slew || 'fast';
        var pullup = pinMode.pullup || 'disabled';
        var pinData = my.pin_data(slew, 'out', pullup, pin.pwm.muxmode);
        if(my.load_dt('am33xx_pwm') && my.create_dt(pin, pinData, 'bspwm')) {
            var ocp = my.file_find('/sys/devices', 'ocp.');
            var pwm_test = my.file_find(ocp, 'bs_pwm_test_' + pin.key + '.', 10000);
            my.file_find(pwm_test, 'period', 10000);
            pwm[pin.pwm.name].pwm_test_path = pwm_test;
            pwm[pin.pwm.name].freq = 0;
            path = pwm_test;
            fs.writeFileSync(path+'/polarity', 0);
        } else {
            pwm[pin.pwm.name].old_pwm_path = '/sys/class/pwm/' + pin.pwm.path;
            path = pwm[pin.pwm.name].old_pwm_path;

            f.pinMode(pin, g.OUTPUT, pin.pwm.muxmode, 'disabled', 'fast');

            // Clear up any unmanaged usage
            fs.writeFileSync(path+'/request', '0');

            // Allocate and configure the PWM
            fs.writeFileSync(path+'/request', '1');
            fs.writeFileSync(path+'/period_freq', Math.round(freq));
            fs.writeFileSync(path+'/polarity', '0');
            fs.writeFileSync(path+'/run', '1');
            pwm[pin.pwm.name].freq = freq;
        }
        pwm[pin.pwm.name].key = pin.key;
    }

    // Perform update only
    if(typeof pwm[pin.pwm.name].pwm_test_path === 'string') {
        path = pwm[pin.pwm.name].pwm_test_path;
        try {
            var period = Math.round( 1.0e9 / freq ); // period in ns
            var duty = Math.round( period * value );
            fs.writeFileSync(path+'/duty', 0);
            if(pwm[pin.pwm.name].freq != freq) {
                fs.writeFileSync(path+'/period', period);
                pwm[pin.pwm.name].freq = freq;
            }
            fs.writeFileSync(path+'/duty', duty);
        } catch(ex) {
            winston.error('analogWrite error: ' + path + ', ' + ex);
        }
    } else {
        path = pwm[pin.pwm.name].old_pwm_path;
        if(pwm[pin.pwm.name].freq != freq) {
            fs.writeFileSync(path+'/run', '0');
            fs.writeFileSync(path+'/duty_percent', '0');
            fs.writeFileSync(path+'/period_freq', Math.round(freq));
            fs.writeFileSync(path+'/run', '1');
            pwm[pin.pwm.name].freq = freq;
        }
        fs.writeFileSync(path+'/duty_percent', Math.round(value*100));
    }

    // All done
    if(callback) callback({value:true});
    return(true);
};
f.analogWrite.args = ['pin', 'value', 'freq', 'callback'];

f.getEeproms = function(callback) {
    var eeproms = {};
    if(!my.is_capemgr()) {
        var EepromFiles = {
            '/sys/bus/i2c/drivers/at24/1-0050/eeprom': { type: 'bone' },
            '/sys/bus/i2c/drivers/at24/3-0054/eeprom': { type: 'cape' },
            '/sys/bus/i2c/drivers/at24/3-0055/eeprom': { type: 'cape' },
            '/sys/bus/i2c/drivers/at24/3-0056/eeprom': { type: 'cape' },
            '/sys/bus/i2c/drivers/at24/3-0057/eeprom': { type: 'cape' }
        };
        eeproms = eeprom.readEeproms(EepromFiles);
        if(eeproms == {}) {
            if(debug) winston.debug('No valid EEPROM contents found');
        }
    } else {
        var boardName = fs.readFileSync(my.is_capemgr() + '/baseboard/board-name',
                'ascii');
        var version = fs.readFileSync(my.is_capemgr() + '/baseboard/revision',
                'ascii');
        var serialNumber = fs.readFileSync(my.is_capemgr() + '/baseboard/serial-number',
                'ascii');
        eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'] = {};
        eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].boardName = boardName;
        eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].version = version;
        eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].serialNumber = serialNumber;
    }
    if(callback) {
        callback(eeproms);
    }
    return(eeproms);
};
f.getEeproms.args = ['callback'];

f.readTextFile = function(filename, callback) {
    if(typeof callback == 'function') {
        var cb = function(err, data) {
            callback({'err':err, 'data':data});
        };
        fs.readFile(filename, 'ascii', cb);
    } else {
        return fs.readFileSync(filename, 'ascii');
    }
};
f.readTextFile.args = ['filename', 'callback'];

f.writeTextFile = function(filename, data, callback) {
    if(typeof callback == 'function') {
        var cb = function(err) {
            callback({'err':err});
        };
        fs.writeFile(filename, data, 'ascii', cb);
    } else {
        try {
            return fs.writeFileSync(filename, data, 'ascii');
        } catch(ex) {
            winston.error("writeTextFile error: " + ex);
            return(false);
        }
    }
};
f.writeTextFile.args = ['filename', 'data', 'callback'];

f.getPlatform = function(callback) {
    var platform = {
        'platform': bone,
        'name': "BeagleBone",
        'bonescript': package_json.version
    };
    if(my.file_existsSync(my.is_capemgr() + '/baseboard/board-name')) {
        platform.name = fs.readFileSync(my.is_capemgr() + '/baseboard/board-name',
                'ascii').trim();
        if(platform.name == 'A335BONE') platform.name = 'BeagleBone';
        if(platform.name == 'A335BNLT') platform.name = 'BeagleBone Black';
        platform.version = fs.readFileSync(my.is_capemgr() + '/baseboard/revision',
                'ascii').trim();
        if(!platform.version.match(/^[\040-\176]*$/)) delete platform.version;
        platform.serialNumber = fs.readFileSync(my.is_capemgr() +
                '/baseboard/serial-number', 'ascii').trim();
        if(!platform.serialNumber.match(/^[\040-\176]*$/)) delete platform.serialNumber;
    }
    if(callback) callback(platform);
    return(platform);
};
f.getPlatform.args = ['callback'];

f.echo = function(data, callback) {
    winston.info(data);
    callback({'data': data});
    return(data);
};
f.echo.args = ['data', 'callback'];

f.setDate = function(date, callback) {
    child_process.exec('date -s "' + date + '"', dateResponse);
    function dateResponse(error, stdout, stderr) {
        if(typeof callback != 'function') return;
        if(error) callback({'error': error});
        if(stdout) callback({'stdout': stdout});
        if(stderr) callback({'stderr': stderr});
    }
};
f.setDate.args = ['date', 'callback'];

// Exported variables
exports.bone = bone; // this likely needs to be platform and be detected
for(var x in f) {
    exports[x] = f[x];
}
for(var x in functions) {
    exports[x] = functions[x];
}
for(var x in serial) {
    exports[x] = serial[x];
}
for(var x in iic) {
    exports[x] = iic[x];
}
for(var x in g) {
    exports[x] = g[x];
}

// Global variable assignments
// This section is broken out because it will eventually be deprecated
var alreadyRan = false;
function setGlobals() {
    for(var x in exports) {
        global[x] = exports[x];
    }
    global.run = run;
    process.nextTick(run);

    function run() {
        if(alreadyRan) return(false);
        alreadyRan = true;
        // 'setup' and 'loop' are globals that may or may not be defined
        if(typeof global.setup == 'function') global.setup();
        while(1) {
            if(typeof global.loop == 'function') global.loop();
        }
    }
}

exports.setGlobals = setGlobals;
